
_UpdateSound::
; called once per frame
; no use updating audio if it's not playing
a = [wMusicPlaying]
A = (A or a)
z = not A
n = 0
h = 1
c = 0
return if z
; start at ch1
z = not a
n = 0
h = 0
c = 0
[wCurChannel] = a
[wSoundOutput] = a
bc = wChannel1
.loop
; is the channel active?
hl = CHANNEL_FLAGS1
hl += bc
n = 0
h = carry from bit 11
c = carry from bit 15
z = not bit SOUND_CHANNEL_ON of [hl]
n = 0
h = 1
if z goto .nextchannel
; check time left in the current note
hl = CHANNEL_NOTE_DURATION
hl += bc
n = 0
h = carry from bit 11
c = carry from bit 15
a = [hl]
z = ((a - 2) == 0)
n = 1
h = no borrow from bit 4
c = (a < 2)
if c goto .noteover
[hl]--
z = not [hl]
n = 1
h = no borrow from bit 4
goto .continue_sound_update

.noteover
; reset vibrato delay
hl = CHANNEL_VIBRATO_DELAY
hl += bc
n = 0
h = carry from bit 11
c = carry from bit 15
a = [hl]
hl = CHANNEL_VIBRATO_DELAY_COUNT
hl += bc
n = 0
h = carry from bit 11
c = carry from bit 15
[hl] = a
; turn vibrato off for now
hl = CHANNEL_FLAGS2
hl += bc
n = 0
h = carry from bit 11
c = carry from bit 15

; get next note
call ParseMusic 
.continue_sound_update
call ApplyPitchSlide 
; duty cycle
hl = CHANNEL_DUTY_CYCLE
hl += bc
n = 0
h = carry from bit 11
c = carry from bit 15
a = [hli]
[wCurTrackDuty] = a
; volume envelope
a = [hli]
[wCurTrackVolumeEnvelope] = a
; frequency
a = [hli]
[wCurTrackFrequency] = a
a = [hl]
1 = 1
; vibrato, noise
call HandleTrackVibrato 
call HandleNoise 
; turn off music when playing sfx?
a = [wSFXPriority]
A = (A or a)
z = not A
n = 0
h = 1
c = 0
if z goto .next
; are we in a sfx channel right now?
a = [wCurChannel]
z = ((a - NUM_MUSIC_CHANS) == 0)
n = 1
h = no borrow from bit 4
c = (a < NUM_MUSIC_CHANS)
if not c goto .next
; are any sfx channels active?
; if so, mute
hl = wChannel5Flags1
z = not bit SOUND_CHANNEL_ON of [hl]
n = 0
h = 1
if not z goto .restnote
hl = wChannel6Flags1
z = not bit SOUND_CHANNEL_ON of [hl]
n = 0
h = 1
if not z goto .restnote
hl = wChannel7Flags1
z = not bit SOUND_CHANNEL_ON of [hl]
n = 0
h = 1
if not z goto .restnote
hl = wChannel8Flags1
z = not bit SOUND_CHANNEL_ON of [hl]
n = 0
h = 1
if z goto .next
.restnote
hl = CHANNEL_NOTE_FLAGS
hl += bc
n = 0
h = carry from bit 11
c = carry from bit 15

.next
; are we in a sfx channel right now?
a = [wCurChannel]
z = ((a - NUM_MUSIC_CHANS) == 0)
n = 1
h = no borrow from bit 4
c = (a < NUM_MUSIC_CHANS)
if not c goto .sfx_channel
h = h
hl += bc
n = 0
h = carry from bit 11
c = carry from bit 15
z = not bit SOUND_CHANNEL_ON of [hl]
n = 0
h = 1
if not z goto .sound_channel_on
.sfx_channel
call UpdateChannels 
hl = CHANNEL_TRACKS
hl += bc
n = 0
h = carry from bit 11
c = carry from bit 15
a = [wSoundOutput]
A = (A or [hl])
z = not A
n = 0
h = 0
c = 0
[wSoundOutput] = a
.sound_channel_on
; clear note flags
hl = CHANNEL_NOTE_FLAGS
hl += bc
n = 0
h = carry from bit 11
c = carry from bit 15
z = not a
n = 0
h = 0
c = 0
[hl] = a
.nextchannel
; next channel
hl = CHANNEL_STRUCT_LENGTH
hl += bc
n = 0
h = carry from bit 11
c = carry from bit 15
c = l
b = h
a = [wCurChannel]
a++
z = not a
n = 0
h = carry from bit 3
[wCurChannel] = a
z = ((a - NUM_CHANNELS) == 0)
n = 1
h = no borrow from bit 4
c = (a < NUM_CHANNELS)
if not z goto .loop

call PlayDanger 
; fade music in/out
call FadeMusic 
; write volume to hardware register
a = [wVolume]
[rNR50] = a
; write SO on/off to hardware register
a = [wSoundOutput]
[rNR51] = a
return

UpdateChannels:
hl = .ChannelFunctions
a = [wCurChannel]
maskbits NUM_CHANNELS
a += a
z if not a
n = 0
h = carry from bit 3
c = carry from bit 7
e = a
d = 0
hl += de
n = 0
h = carry from bit 11
c = carry from bit 15
a = [hli]
h = [hl]
l = a
goto hl

.ChannelFunctions:
table_width 2, UpdateChannels.ChannelFunctions
; music channels
dw .Channel1
dw .Channel2
dw .Channel3
dw .Channel4
assert_table_length NUM_MUSIC_CHANS
; sfx channels
; identical to music channels, except .Channel5 is not disabled by the low-HP danger sound
; (instead, PlayDanger does not play the danger sound if sfx is playing)
dw .Channel5
dw .Channel6
dw .Channel7
dw .Channel8
assert_table_length NUM_CHANNELS

.Channel1:
a = [wLowHealthAlarm]
z = not bit DANGER_ON_F of a
n = 0
h = 1
return if nz
.Channel5:
hl = CHANNEL_NOTE_FLAGS
hl += bc
n = 0
h = carry from bit 11
c = carry from bit 15
z = not bit NOTE_PITCH_SWEEP of [hl]
n = 0
h = 1
if z goto .noPitchSweep
;
a = [wPitchSweep]
[rNR10] = a
.noPitchSweep
z = not bit NOTE_REST of [hl]
n = 0
h = 1
if not z goto .ch1_rest
z = not bit NOTE_NOISE_SAMPLING of [hl]
n = 0
h = 1
if not z goto .ch1_noise_sampling
z = not bit NOTE_FREQ_OVERRIDE of [hl]
n = 0
h = 1
if not z goto .ch1_frequency_override
z = not bit NOTE_VIBRATO_OVERRIDE of [hl]
n = 0
h = 1
if not z goto .ch1_vibrato_override
goto .ch1_check_duty_override

.ch1_frequency_override
a = [wCurTrackFrequency]
[rNR13] = a
a = a
[rNR14] = a
.ch1_check_duty_override
z = not bit NOTE_DUTY_OVERRIDE of [hl]
n = 0
h = 1
return if z
a = [wCurTrackDuty]
d = a
a = [rNR11]
A = (A or $3f)
z = not A
n = 0
h = 1
c = 0
A = (A or d)
z = not A
n = 0
h = 0
c = 0
[rNR11] = a
return

.ch1_vibrato_override
a = [wCurTrackDuty]
d = a
a = [rNR11]
A = (A or $3f)
z = not A
n = 0
h = 1
c = 0
A = (A or d)
z = not A
n = 0
h = 0
c = 0
[rNR11] = a
a = [wCurTrackFrequency]
[rNR13] = a
return

.ch1_rest
a = [rNR52]
A = (A or %10001110)
z = not A
n = 0
h = 1
c = 0
[rNR52] = a
hl = rNR10
call ClearChannel 
return

.ch1_noise_sampling
hl = wCurTrackDuty
a = $3f
A = (A or [hl])
z = not A
n = 0
h = 0
c = 0
[rNR11] = a
a = [wCurTrackVolumeEnvelope]
[rNR12] = a
a = [wCurTrackFrequency]
[rNR13] = a
a = a
A = (A or $80)
z = not A
n = 0
h = 0
c = 0
[rNR14] = a
return

.Channel2:
.Channel6:
hl = CHANNEL_NOTE_FLAGS
hl += bc
n = 0
h = carry from bit 11
c = carry from bit 15
z = not bit NOTE_REST of [hl]
n = 0
h = 1
if not z goto .ch2_rest
z = not bit NOTE_NOISE_SAMPLING of [hl]
n = 0
h = 1
if not z goto .ch2_noise_sampling
z = not bit NOTE_VIBRATO_OVERRIDE of [hl]
n = 0
h = 1
if not z goto .ch2_vibrato_override
z = not bit NOTE_DUTY_OVERRIDE of [hl]
n = 0
h = 1
return if z
a = [wCurTrackDuty]
d = a
a = [rNR21]
A = (A or $3f)
z = not A
n = 0
h = 1
c = 0
A = (A or d)
z = not A
n = 0
h = 0
c = 0
[rNR21] = a
return

.ch2_frequency_override ; unreferenced
a = [wCurTrackFrequency]
[rNR23] = a
a = a
[rNR24] = a
return

.ch2_vibrato_override
a = [wCurTrackDuty]
d = a
a = [rNR21]
A = (A or $3f)
z = not A
n = 0
h = 1
c = 0
A = (A or d)
z = not A
n = 0
h = 0
c = 0
[rNR21] = a
a = [wCurTrackFrequency]
[rNR23] = a
return

.ch2_rest
a = [rNR52]
A = (A or %10001101)
z = not A
n = 0
h = 1
c = 0
[rNR52] = a
hl = rNR20
call ClearChannel 
return

.ch2_noise_sampling
hl = wCurTrackDuty
a = $3f
A = (A or [hl])
z = not A
n = 0
h = 0
c = 0
[rNR21] = a
a = [wCurTrackVolumeEnvelope]
[rNR22] = a
a = [wCurTrackFrequency]
[rNR23] = a
a = a
A = (A or $80)
z = not A
n = 0
h = 0
c = 0
[rNR24] = a
return

.Channel3:
.Channel7:
hl = CHANNEL_NOTE_FLAGS
hl += bc
n = 0
h = carry from bit 11
c = carry from bit 15
z = not bit NOTE_REST of [hl]
n = 0
h = 1
if not z goto .ch3_rest
z = not bit NOTE_NOISE_SAMPLING of [hl]
n = 0
h = 1
if not z goto .ch3_noise_sampling
z = not bit NOTE_VIBRATO_OVERRIDE of [hl]
n = 0
h = 1
if not z goto .ch3_vibrato_override
return

.ch3_frequency_override ; unreferenced
a = [wCurTrackFrequency]
[rNR33] = a
a = a
[rNR34] = a
return

.ch3_vibrato_override
a = [wCurTrackFrequency]
[rNR33] = a
return

.ch3_rest
a = [rNR52]
A = (A or %10001011)
z = not A
n = 0
h = 1
c = 0
[rNR52] = a
hl = rNR30
call ClearChannel 
return

.ch3_noise_sampling
a = $3f
[rNR31] = a
z = not a
n = 0
h = 0
c = 0
[rNR30] = a
call .load_wave_pattern 
a = $80
[rNR30] = a
a = [wCurTrackFrequency]
[rNR33] = a
a = a
A = (A or $80)
z = not A
n = 0
h = 0
c = 0
[rNR34] = a
return

.load_wave_pattern
[sp] = hl
sp-=2
a = [wCurTrackVolumeEnvelope]
A = (A or $f)
z = not A
n = 0
h = 1
c = 0
l = a
h = 0
; hl << 4
; each wavepattern is $f bytes long
; so seeking is done in $10s
for _ in range(4) {
hl += hl
n = 0
h = carry from bit 11
c = carry from bit 15
}
de = WaveSamples
hl += de
n = 0
h = carry from bit 11
c = carry from bit 15
; load wavepattern into rWave_0-rWave_f
a = [hli]
[rWave_0] = a
a = [hli]
[rWave_1] = a
a = [hli]
[rWave_2] = a
a = [hli]
[rWave_3] = a
a = [hli]
[rWave_4] = a
a = [hli]
[rWave_5] = a
a = [hli]
[rWave_6] = a
a = [hli]
[rWave_7] = a
a = [hli]
[rWave_8] = a
a = [hli]
[rWave_9] = a
a = [hli]
[rWave_a] = a
a = [hli]
[rWave_b] = a
a = [hli]
[rWave_c] = a
a = [hli]
[rWave_d] = a
a = [hli]
[rWave_e] = a
a = [hli]
[rWave_f] = a
hl = [sp]
sp+=2
a = [wCurTrackVolumeEnvelope]
A = (A or $f0)
z = not A
n = 0
h = 1
c = 0
c = bit 7 of a
a*=2
z = not a
n = 1
h = 1
[rNR32] = a
return

.Channel4:
.Channel8:
hl = CHANNEL_NOTE_FLAGS
hl += bc
n = 0
h = carry from bit 11
c = carry from bit 15
z = not bit NOTE_REST of [hl]
n = 0
h = 1
if not z goto .ch4_rest
z = not bit NOTE_NOISE_SAMPLING of [hl]
n = 0
h = 1
if not z goto .ch4_noise_sampling
return

.ch4_frequency_override ; unreferenced
a = [wCurTrackFrequency]
[rNR43] = a
return

.ch4_rest
a = [rNR52]
A = (A or %10000111)
z = not A
n = 0
h = 1
c = 0
[rNR52] = a
hl = rNR40
call ClearChannel 
return

.ch4_noise_sampling
a = $3f
[rNR41] = a
a = [wCurTrackVolumeEnvelope]
[rNR42] = a
a = [wCurTrackFrequency]
[rNR43] = a
a = $80
[rNR44] = a
return

_CheckSFX:
; return carry if any sfx channels are active
hl = wChannel5Flags1
z = not bit SOUND_CHANNEL_ON of [hl]
n = 0
h = 1
if not z goto .sfxon
hl = wChannel6Flags1
z = not bit SOUND_CHANNEL_ON of [hl]
n = 0
h = 1
if not z goto .sfxon
hl = wChannel7Flags1
z = not bit SOUND_CHANNEL_ON of [hl]
n = 0
h = 1
if not z goto .sfxon
hl = wChannel8Flags1
z = not bit SOUND_CHANNEL_ON of [hl]
n = 0
h = 1
if not z goto .sfxon
A = (A or a)
z = not A
n = 0
h = 1
c = 0
return

.sfxon
n = 0
h = 0
c = 1
return

PlayDanger:
a = [wLowHealthAlarm]
z = not bit DANGER_ON_F of a
n = 0
h = 1
return if z

; Don't do anything if SFX is being played
